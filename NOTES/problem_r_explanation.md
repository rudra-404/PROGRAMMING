## n তম প্রাইম খুঁজে বের করা :

```c
#include <stdio.h>

#define MAX 2000000

int v[MAX];  // প্রাইম সংখ্যা স্টোর করার জন্য array
int p[MAX + 1];  // Sieve Algorithm এর জন্য array
int prime_count = 0;  // প্রাইম সংখ্যা count করার জন্য একটি counter

void sieve() {
    for (int i = 0; i <= MAX; i++) {
        p[i] = 1;  // সব সংখ্যা প্রথমে প্রাইম ধরে নিলাম
    }
    p[0] = p[1] = 0;  // 0 এবং 1 প্রাইম নয়, তাই FALSE বা 0 assign করে দিলাম

    for (int i = 2; i <= MAX; i++) {
        if (p[i]) {  
            v[prime_count++] = i;  // প্রাইম সংখ্যা স্টোর
            for (int j = i * 2; j <= MAX; j += i) {
                p[j] = 0;  // প্রাইম নয় এমন সংখ্যা FALSE বা 0 করে দেওয়া
            }
        }
    }
}

int main() {
    sieve();  // শুরুতেই সব প্রাইম সংখ্যা বের করা নেওয়া

    int test;
    scanf("%d", &test);  // টেস্ট কেস

    while (test--) {
        int n;
        scanf("%d", &n);
        printf("%d\n", v[n - 1]);  // n-তম প্রাইম সংখ্যা প্রিন্ট
    }

    return 0;
}
```

<br><br>

## Code Explanation :

#### **1. প্রয়োজনীয় ডিক্লেয়ারেশন:**
```c
#define MAX 2000000

int v[MAX];
int p[MAX + 1];
int prime_count = 0;
```
- **`MAX`** → প্রোগ্রামটির জন্য সর্বোচ্চ সীমা ২,০০,০০০০ পর্যন্ত নেওয়া হয়েছে, অর্থাৎ প্রোগ্রামটি ২,০০,০০০০ পর্যন্ত প্রাইম সংখ্যা বের করবে।
- **`v[MAX]`** → প্রাইম সংখ্যাগুলি এখানে **স্টোর** করা হবে। `v[i]`-এ **i+১-তম প্রাইম সংখ্যা** থাকবে।
- **`p[MAX + 1]`** → এটি একটি অ্যারে যা **Sieve Algorithm** ব্যবহার করে সেগুলির প্রাইম বা কম্পোজিট (অপ্রাইম) হওয়া নির্ধারণ করবে।  
  - **`p[i]` এর মান 1** হলে, `i` একটি **প্রাইম সংখ্যা**, এবং **`p[i]` এর মান 0** হলে, `i` একটি **অপ্রাইম সংখ্যা** (কম্পোজিট)।

---

#### **2. Sieve Algorithm (প্রাইম সংখ্যা বের করা):**
```c
void sieve() {
    for (int i = 0; i <= MAX; i++) {
        p[i] = 1;  
    }
    p[0] = p[1] = 0;  
```
- এখানে প্রথমে **`p[i]`** সবগুলোকে **১** দিয়ে **প্রাইম** হিসেবে ধরে নেওয়া হয়। তারপর, **`p[0]`** এবং **`p[1]`** কে **০** দেওয়া হয়, কারণ ০ এবং ১ প্রাইম সংখ্যা নয়।
  
```c
    for (int i = 2; i <= MAX; i++) {
        if (p[i]) {  
            v[prime_count++] = i;  
            for (int j = i * 2; j <= MAX; j += i) {
                p[j] = 0;  
            }
        }
    }
}
```
- এই লুপটি **Sieve of Eratosthenes** অ্যালগরিদম অনুসারে কাজ করে:
  1. **প্রথমে ২** থেকে শুরু করে সব সংখ্যার জন্য চেক করা হয়।
  2. যদি **`p[i] == 1`** (অর্থাৎ `i` প্রাইম সংখ্যা), তবে:
      - `i` কে **`v[]`** অ্যারেতে **স্টোর** করা হয়।
      - তারপর, `i` এর গুণিতকগুলি (যেমন `2i, 3i, 4i, ...`) বের করে **`p[j] = 0`** করে দেওয়া হয়, কারণ তারা আর প্রাইম নয়।
  3. এভাবে, একে একে সব প্রাইম সংখ্যা বের হয়ে যাবে।

---

#### **3. মূল প্রোগ্রাম (Main Function):**
```c
int main() {
    sieve();  
```
- **`sieve()`** ফাংশন কল করা হয় যাতে প্রথমে সব প্রাইম সংখ্যা বের করা হয় এবং **`v[]`** অ্যারেতে সংরক্ষিত হয়।

```c
    int test;
    scanf("%d", &test);  
```
- প্রথমে **টেস্ট কেস** ইনপুট নেয়া হয়, যা দিয়ে বলা হয় যে কতবার ইউজারের কাছ থেকে ইনপুট নেয়া হবে।

```c
    while (test--) {
        int n;
        scanf("%d", &n);
        printf("%d\n", v[n - 1]); 
    }
```
- **এই লুপটি টেস্ট কেসের জন্য** কাজ করে।
  - `n` ইনপুট নেয়া হয়, যা **n-তম প্রাইম সংখ্যা** চাওয়ার জন্য।
  - প্রাইম সংখ্যা গুলি **`v[]`** অ্যারেতে সংরক্ষিত আছে, তাই **`v[n - 1]`** দিয়ে আমরা **n-তম প্রাইম** সংখ্যা বের করে **প্রিন্ট** করি।

---

### **নমুনা ইনপুট এবং আউটপুট:**

#### **ইনপুট:**
```
3
1
5
10
```

#### **আউটপুট:**
```
2
11
29
```

#### **ব্যাখ্যা:**
- প্রথম ইনপুট: 1 → 1-তম প্রাইম সংখ্যা **2**।
- দ্বিতীয় ইনপুট: 5 → 5-তম প্রাইম সংখ্যা **11**।
- তৃতীয় ইনপুট: 10 → 10-তম প্রাইম সংখ্যা **29**।

এভাবে, প্রোগ্রামটি **প্রতিটি টেস্ট কেসের জন্য প্রাইম সংখ্যা প্রিন্ট করবে।**

---

### **সংক্ষেপে কোডের কাজ:**
1. **প্রথমে Sieve of Eratosthenes** অ্যালগরিদম ব্যবহার করে প্রাইম সংখ্যা বের করা হয়।
2. **টেস্ট কেস অনুযায়ী**, ইউজার যেই **n-তম প্রাইম** চায়, তা **`v[]` অ্যারে** থেকে বের করে প্রিন্ট করা হয়।